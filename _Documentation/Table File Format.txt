***********************************************************************
                        Table File Format (TBL)
                       written by: Nightcrawler

                             Nightcrawler's
                         Translation Corporation
                      http://transcorp.parodius.com

                           Contributions From:
                    Tauwasser, Klarth, DaMarsMan, abw,
                        KingMike, Gil Galad, snarf
					
                            Version 1.0 Draft
                              28 March 2012
***********************************************************************


Table of Contents

1.0 Information
	1.1 Overview
	1.2 What is a Table File?
	
2.0 Table File Format
	2.1 General Format Overview
	2.2 Declaration of Conformance
		2.2.1 Compliancy Requirements
		2.2.2 Level of Compliance
	2.3 Encoding
		2.3.1 Format
		2.3.2 Byte Order Mark (BOM)
	2.4 Normal Entries
	2.5 Non-Normal Entries
		2.5.1 Control Codes '$'
		2.5.2 End Tokens '/'
		2.5.3 Table Switching '!'
	2.6 Line Breaks "\n"
	2.7 Raw Hex Representation
	2.8 No-Entry-Found Behavior for Dumping
	2.9 No-Entry-Found Behavior for Inserting
	2.10 Hex Collisions
	2.11 Text Collisions
	2.12 Illegal Sequences
	2.13 Ambiguous Situations
	
3.0 How to Handle Common Situations
	3.1 Dictionary Compression
	3.2 Handakuten/Dakuten
	3.3 Kanji or Han Ideographs
	3.4 Hiragana/Katakana Table Switching
	
4.0 Suggestions to Programmers handling Table Files
	4.1 Cross-Platform Newline Support
	4.2 Dumping vs. Inserting Considerations
	4.3 Data Structures for Entry Handling

5.0 Lexical Definitions


	
1.0 Information


	1.1 Overview
		
		Table files have been used in various forms since the early days of the 
		ROM hacking community. They have lived from their barbaric 
		pencil-and-paper roots till modern-day dumping and insertion utilities 
		albeit lacking an official format specification. As a result, the table 
		file format has gone through many variations at the whim of any utility 
		creator or ROM hacker. For years, this has caused a great many headaches 
		for ROM hackers and countless incompatibilities amongst uses for various 
		utilities. This document's purpose is to document and standardize the 
		table file format in hopes that ROM hackers can progress forward with 
		compatible utilities, clear indication of format, and standardized 
		features. 

		This document was created by reviewing documentation and features of 
		various utilities throughout ROM hacking history, including: Atlas, 
		Cartographer, Thingy98, Hexecute, Hexposure, Translhextion, and others. 
		The idea was to put together the most commonly supported table file 
		features, review their relevance to the primary purpose of a table file, 
		and update to meet current needs. Only generic features directly 
		contributing to hex-to-text conversion and vice versa remain. All 
		features found to be specific to a particular game, hex editor, dumper 
		or inserter were removed. Effort was made to extend capabilities of 
		existing features, add new features, and keep the ease of migration to 
		the new format in mind. 
		
		The resulting specification has been contributed to and reviewed by 
		interested community software creators and end users. It is a good faith 
		compromise to meet the needs of as many community members as possible 
		and remain true to the original objectives. While the objective is 
		standardizing table files, by its nature it also standardizes some 
		aspects of the textual representation of the dumping and insertion 
		process. As such, these definitions encroach to some degree on defining 
		the dumping and inserting process. 
	
		
	1.2 What is a Table File?
				
		A Table File is a simple text file with the TBL file extension. Its 
		sole purpose is to act as a hex-to-text and text-to-hex encoding file. 
		Basically, this means it's a table to turn binary data into text and 
		vice versa. This is what ROM hackers use to extract readable text from a 
		video game. It's also what is used to take that text and turn it back 
		into binary to be inserted into a game. While the format specifically
		services needs of the ROM hacking community, its usefulness may extend
		to other areas.

		Each line of the table file will be referred to as an "entry". Aside from 
		special cases, each line indicates what string of text a sequence of 
		hexadecimal bytes equates to. A table file is analogous to a big dictionary 
		where the words are hexadecimal and the definition is readable text. 
		Some special entries exist to indicate advanced instructions that a 
		script dumper or inserter would use to handle cases such as: end text 
		indications, special script formatting, or other more advanced 
		situations. The majority of the time table files will consist of simple 
		normal entries and end-of-text indication. As ROM hacking skills grow, 
		more advanced features can be utilized. 



2.0 Table File Format

		
	2.1 General Format Overview
	
		The Table File Format is self-declared (per section 2.2 requirements) 
		standard for a UTF-8 encoded (See section 2.3) text file with each line 
		consisting of a single TableID (Section 2.5.3), 'Normal' (Section 2.4), or 
		'Non-Normal' (Section 2.5) entry. Such entries shall map hex-to-text and 
		text-to-text sequences of a given text encoding system. 
				
	2.2 Declaration of Conformance
	
		2.2.1 Compliancy Requirements
		
			For an implementation to be considered in compliance with this standard, 
			the following steps are required: 

			1. A self-declaration of conformance shall be made to the end user via 
			   documentation or user interface that indicates that this standard is 
			   being used. 
			2. Indication of the level of compliance chosen shall be declared. 
			3. Reference to a separate copy of this document shall be given whether 
			   online link or local copy.
			4. All items contained in this document shall be followed.
		
		2.2.2 Level of Compliance
				
			In order to ensure uniform and predictable output amongst 
			implementations of this standard, level of compliance should be declared 
			based on the applicable chosen algorithm. 
			
			Level 1 Compliance:
			
				Level 1 indicates the "Longest Prefix" algorithm has been chosen for 
				handling text collisions.
				
			Level 2 Compliance:
				
				Level 2 indicates an "Optimal Path" algorithm has been chosen for 
				handling text collisions.
				
	2.3 Encoding

		2.3.1 Format
		
			Table files must always be encoded in UTF-8 format. It is the widest 
			supported global text encoding standard available. Nearly all text 
			editors support saving files in this format. Even Windows Notepad 
			provides this option in the "Save As" dialog box. Some outdated ROM 
			hacking utilities may not support UTF-8, but it is essential to use this 
			format going forward for global language compatibility. This document is 
			encoded in UTF-8 format. 

		2.3.2 Byte Order Mark (BOM)
		
			The Unicode BOM is strongly encouraged to be included, but is optional. 
			Utilities following this standard must work in either case. The end 
			user does not need to be concerned with this matter beyond choosing a 
			utility that includes the BOM in its UTF-8 output if given an option. 

	
	2.4 Normal Entries

		Normal Entries will be a simple conversion map for a given hexadecimal and 
		text sequence. 
		
		Format
			
			hexadecimal sequence=text sequence
		
		Rules
				
			1. Each entry must be contained on a single line.
			2. Hex sequences must be an even number of characters.
			3. Hex sequences must be big endian (most significant to least significant) 
			4. Hex sequences and Text sequences have no practical limit on length.
			5. Whitespace is allowed in the text sequence only.
			6. Text sequences may not contain '[' or ']' characters. These characters are
			   reserved for Non-Normal entries and Raw Hex. See 2.5 and 2.7 respectively.
			
		Single-byte entries look like this:

			00=A
			01=B
			02=C
			3E=あ
			3F=い
			40=う

		Multi-byte entries look like this:

			12345678=A

		Multi-character entries look like this:

			00=Test

		A combination of the two looks like this:

			1234=Test
			

	2.5	Non-Normal Entries

		Non-Normal entries require special handling or marking beyond that of 
		Normal Entries to assist in hex-to-text and text-to-hex mapping. These 
		entries include control codes, end tokens, and table switching. 
		
		Non-Normal entries are defined in the following format:
			
			Prefixed hexadecimal sequence=[Label],Parameter1,Parameter2,Parameter3 etc.
		
		General Rules:
		
			1. Each entry must be contained on a single line.
			2. Hex sequences must be an even number of characters.
			3. Hex sequences must be big endian (most significant to least significant) 
			4. Hex sequences have no practical limit on length.
						
		Prefixes:	
				
			1. '$' - General Control Codes	
			2. '/' - End Tokens
			3. '!' - Table Switching
		
		Label:
				
			The Label is the identifying name for the control and is enclosed by the 
			'[' and ']' characters. 
				
			1. Labels should be unique across the logical table. 
			2. If applicable to a given prefix, labels will be used for text sequence representation of the entry.
			3. Labels should consist only of digits [0-9A-Za-z].
			4. Labels cannot be empty.
			5. Labels may be followed by "\n" line breaks. See section 2.6.
				
		Parameters:
		
			Parameters are for applicable associated information necessary to 
			process a Non-Normal entry. Parameters may be optional depending on the 
			prefix used. The details of the parameters fields can be found in the 
			following sections specific to the prefix type. 
		
		2.5.1 Control Codes '$'
						
			"Control Codes" are a flexible method of which to represent sequence 
			maps that do not have direct meaning to the text encoding/decoding 
			process. Such indirect "control" sequences may represent items such as 
			text formatting, line breaks, text windows, colors, or key presses. 
			
			It is often desirable and sometimes even necessary that control codes be 
			expressly included in the map, along with direct text mappings. These 
			codes contain pertinent attributes useful for processing. In addition to 
			this, control codes may include associated parameters of their own, 
			specific to the individual code. 
			
			End tokens and Table Switching may be considered control codes. Such 
			controls shall be handled per section 2.5.2 and 2.5.3 respectively. All 
			other controls not specifically recognized by this standard shall be 
			handled in this general fashion. 
			
			Control Code entries are defined in the following format: 
			
				$hexadecimal sequence=[label],parameter1,parameter2 etc.
				
			The '$' prefix is required and the label follows the rules outlined in 
			section 2.5.
				
			Parameters:
				
				Parameters, as applied to Control Codes, are strings with identifying 
				placeholders for linked subsequent hexadecimal parameter bytes. 
				
					1. Parameters are optional for Control Codes.
					2. There may be any fixed number of parameters.
					3. A variable number of parameters is unsupported.
					4. Parameter strings cannot contain characters '[', ']', or ','.
					5. "%%" may be used for literal '%'
					6. There shall be one parameter byte associated with each parameter
					   string.
					
			Placeholders:
				
				For each parameter string, one of the following placeholders is 
				expected. This placeholder will specify the format (and position) of the 
				parameter string for an associated binary parameter byte. 
				
					"%D" → Decimal 
					"%X" → Hex 
					"%B" → Binary 
								
			Example 1: General Control Codes w/ no parameters.
				
				This the simplest form for basic control codes.
				
				Table:
					
					21=a
					22=b
					23=c
					$E0=[keypress]\n
					
				Hex Sequence:
										
					0x21,0x22,0xE0,0x23,0x21 
			
				Output for hex-to-text on the above hex sequence:
					
					ab[keypress]
					ca
				
			Example 2: General Control Codes w/ parameters.
			
				Table:
					
					21=a
					A0=A
					$E0=[Color],palette=%X,index=%D
					
				Hex Sequence:
					
					0xA0,0xE0,0xA4,0x34,0x21 
			
				Output for hex-to-text on the above hex sequence:
					
					A[Color palette=$A4 index=52]a
	
		2.5.2 End Tokens '/'	

			A distinguishable string end token for dumping and inserting is 
			necessary, especially with pointers. It will act as a token indicator 
			only. In actual text output, line breaks would still be controlled via 
			"\n" line breaks. (See section 2.6) 
		 
			Format:
					
					/hexsequence=[label]
					
			The '/' prefix is required and the label follows the rules outlined in 
			section 2.5.
				
			Parameters:
				
				There are no parameters allowed for end tokens.
				
			Example 1:	
				
				A typical string end token might look like this in the table:

					/FF=[END]\n\n

				When mapping hex-to-text, any time hex sequence 0xFF is encountered, the 
				text output "[END]" with two line breaks will be output. When mapping 
				text-to-hex, text sequence "[END]" will be output in hex as 0xFF. Note 
				that any line breaks are ignored for insertion purposes per section 2.6. 

		2.5.3 Table Switching '!'

			Support of multiple table files is a flexible approach that can prove 
			useful in situations where different font tables are used or array 
			switching takes place. Some uses for this feature include 
			Handakuten/Dakuten, Kanji, and dictionaries. Some details on these 
			specific situations can be found in section 3. 
			
			Rules:
				
				1. Only a single logical table per table file is allowed.
				2. Multiple switches to the same target table (in the same logical table)
				   are forbidden. 
			
			Table ID:
			
				All tables to be used with switching functionality must include a unique 
				ID line identifying the logical table in the following format:
				
					@TableIDString
				
				A table ID line starts with the '@' character followed by a string 
				uniquely naming the table across all tables. The TableIDString can 
				contain any characters except for ','. 
				
				The TableIDString must be unique across all logical tables.

			Table Switch Format:
			
				!hexadecimal sequence=[TableID],NumberOfMatches

				Notes:
					1. The '!' prefix is required.
					2. The TableID acts as the label and follows the label rules outlined in 
					   section 2.5. 
					3. The NumberOfMatches acts the single required parameter for a Table
					   Switch.
			
			TableID:
				
				1. This is the ID name of the table to switch to. 
				2. The TableID must match the TableIDString of one of the tables designated to
				   be used for switching with a TableIDString identification line. 
			
			NumberOfMatches: 
				
				This is the number of matches to trigger a fallback condition from the 
				new table back to the originating table. When the specified match 
				condition is reached, fallback to the previously used table shall occur. 
			
					'-1'
						Indicates matches should be made in the new table until the originating 
						table switch hex sequence is encountered. 
					'0'
						Indicates indefinite matching shall be done in the new table until no 
						matching entry is found in the table that was switched to. 
					'X' 
						X represents any positive decimal number. X number of matches should be
						made in the new table followed by fallback to the originating table. 

			Matching Rules: 
				
				1. A table switch hex sequence match counts as a match toward satisfying 
				   the fallback condition. 
				2. Encountering Raw Hex bytes during insertion shall override all conditions
				   and cause immediate fallback to starting table (after inserting the byte).

			Example 1:
			
			Assume we have three table files:
				
				Table 1:
			
					@HIRA
					00=あ
					01=い
					02=う
					03=[PlayerName]
					!F8=[KATA],0
					!F9=[KANJI],0

				Table 2:

					@KATA
					00=ア
					01=イ
					02=ウ
					!F8=[HIRA],0
					!F9=[KANJI],0

				Table 3:
				
					@KANJI
					00=亜
					01=意
		 

			The utility will determine starting table. Let's assume we start with table HIRA.

			We have the following hex string to dump:
				
				0xF8 0x00 0x01 0x02 0xF9 0x01 0x03

			The process to dump would be expected to go as follows:
			
				HIRA --> KATA --> ア --> イ --> ウ --> KANJI --> 意 --> 0x03 fallback to KATA --> 0x03 fallback to HIRA --> [PlayerName].				
		
	2.6 Line Breaks "\n"

		Line breaks represented by "\n" may be used after the end of the label 
		portion of Non-Normal Entries to control the formatting and output of 
		the script. Line breaks are used by dumpers only and will be ignored 
		by inserters.
		
		Line breaks will most commonly be used for flexible control of line 
		breaks and string end indications in text output. "\n" could be used to 
		achieve effects like the following: 

		Table Entries:
		
			$FE=[linebreak]\n		(A Control Code without parameters)
			/FF=[end]\n\n			(An End Token)

		This will produce the following at the end of a string:
		
			Sample script string one, line one.[linebreak]
			Sample script string one line two.[end]
					
			Sample script string two, line one.[linebreak]
			etc.
		
		Notice "[linebreak]" is followed by a single line break, while "[end]"
		is followed by two line breaks the text continues as prescribed by the
		table entries.

		Line breaks allow for greater flexibility of controlling the 
		way the script is formatted when dumped rather than needing to formally 
		recognize special entries for line breaks or other control codes that 
		may need special line space formatting.
		
	2.7 Raw Hex Representation

		In instances where raw hex bytes must be represented in text form, the 
		following format should be used: 

			[$XX]
			
		"XX" will represent the raw hex byte consisting of digits [0-9A-Fa-f].
		
		Raw hex is needed when a hex-to-text conversion cannot take place and 
		whenever raw bytes may appear in a text-to-hex conversion. See section 
		2.8. 
			
	2.8 No-Entry-Found Behavior for Dumping

		In the event no table match is found for a given hex sequence, the first 
		byte of the sequence must be output as a raw value as described in section 2.7.
		
		Attempted matching should continue with a new hex sequence starting at 
		the position of the next byte in the source hex stream. Only one-byte 
		misses are possible, because finding no match at offset n does not imply 
		there is no match that fits offset n+1. 

		"[$XX]" sequences must be inserted as raw hex for insertion purposes. 
		
	2.9 No-Entry-Found Behavior for Inserting
	
		In the event no table entry is found to match a given text sequence,
		an error shall be generated. 

	2.10 Hex Collisions
	
		When hex sequences overlap, the longest hex sequence must always be used.

		Example Table Entries:

			00=Five
			01=Six
			0001=Seven

		If a byte sequence 0x00 0x01 is encountered, the string "Seven" shall 
		be mapped as the result and not any other combination. 

	2.11 Text Collisions
	
		When text sequences overlap, the collision will be resolved using one
		of two allowed algorithms. The algorithm chosen in the implementation
		should be declared to the user. (See section 2.2.2)
		
		Longest Prefix Algorithm:
		
			The entry that represents the longest prefix for the current string
			of text shall be used. This is simplest algorithm and recommended for
			less experienced programmers.

			Example 1:

				Table Entries:

					12=Five
					13=Six
					00=FiveSix

				If a text sequence 'FiveSix' is encountered, it shall be mapped to byte 
				0x00 as the result and not any other combination.

		Optimal Path Algorithm:
		
			An optimal path finding algorithm will be used to determine the smallest 
			possible hex representation for a given text-sequence. This algorithm 
			may be implemented in a variety of ways including general backtracking, 
			depth tree searching, or the A* Search algorithm. Implementing this 
			algorithm is recommended only for advanced programmers due to the 
			complexity of table switching. 
			
			Optimal path finding will also allow some rare instances that are not 
			possible to insert with the "Longest Prefix" algorithm. An example of 
			one such case can be seen below: 

			Example Table Entries:
			
				12=Five
				13=SixSeven
				00=FiveSix

			If text sequence "FiveSixSeven" the "Longest Prefix" algorithm makes it
			impossible to insert the string "FiveSixSeven". Using an optimal path finding
			algorithm (the details of which are beyond the scope of this document) would
			arrive at the mapping of 0x12 0x13.

	2.12 Illegal Sequences
	
		Duplicate Hex Sequences:
		
			00=test
			00=test2
			
			Duplicate hex sequences within a single logical table are not allowed
			and shall generate an error.
				
		Blank Hex sequences:
		
			=test
			
			A 'blank' hex sequence is not allowed and shall generate an error.
				
		Unrecognized Line or Invalid Syntax:
			
			In the event a line cannot be parsed, and does not conform to one of the
			acceptable entries defined in this document, an error shall be generated. 
		
	2.13 Ambiguous Situations
		
		Duplicate Text Sequences:
			
			00=test\n
			01=test
			02BC=test	
			
			Duplicate text sequences within a single logical table are unique in the 
			dumping (hex-to-text) direction. To avoid ambiguity in the inserting 
			(text-to-hex) direction, the text sequence should map only to the 
			shortest hex sequence. In the event multiple hex sequences are the same 
			length, the last occurring is used. If present, the "\n" formatting sequence
			shall be ignored when checking for duplication.
			
			Following these rules, the example above maps text sequence "test" to hex 
			sequence "01" in the inserting direction. 

		Blank Text Sequences:
		
			00=
			01=
			
			Entries mapping to an empty text sequence are valid in the dumping 
			direction, but must be ignored in the inserting direction due to having a length of zero. 
	
		Blank Line:
		
			Blank lines must be ignored during parsing.

			
			
3.0 How to Handle Common Situations


	The following section contains supplemental examples of common 
	situations ROM hackers encounter, and how they may be handled using the 
	table file format. The solutions presented are suggestions only. 
	Multiple approaches are possible and care should be taken to find the 
	best solution for the individual job. 
	
	3.1 Dictionary Compression
		
		
		The table file format supports handling dictionary compression by 
		allowing dictionary entries to be input as normal entries. 

		For example using normal entries:
		
			3001=Entry1
			3002=Entry2
			3003=Entry3
		
		or:
		
			01=Entry1
			02=Entry2
			03=Entry3
			
		There are many formats dictionary compression may be in, however most 
		are able to be represented as normal entries. 
		
		Alternatively, table switching can be used for some situations.
		
		Table 1:
		
			@NORMAL
			!30=[DICTIONARY1],1
		
		Table 2:
				
			@DICTIONARY1
			01=DictEntry1
			02=DictEntry2
			03=DictEntry3
				
		In this case, every time hex code 0x30 is encountered, the table will 
		switch for one match from the DICTIONARY1 table and fall back to table 
		NORMAL. This is effectively the same as having the 30XX entries in one 
		table like the first example of the section. 
				
		If the dictionary contains many items and it is impractical to find and 
		type them manually, a separate table can be created for dictionary 
		dumping, for extracting the contents of the dictionary in an automated 
		fashion with a/any dumping utility. The results can then be inserted 
		into a new table file for the final script dumping. 
		
		Ideally, a utility with the ability to output the hex sequence and any 
		special prefix (such as the "30XX=" in our example above) for each dictionary
		item would be preferred.
		
	3.2 Handakuten/Dakuten

		This is a Japanese-language specific issue. Handakuten/Dakuten are small 
		marks added to Japanese characters to add voice. Some games have a 
		special byte to indicate adding a Handakuten/Dakuten mark to the 
		following or preceding character. The table file format supports 
		handling most instances of this through normal entries or dual table 
		support for more complicated scenarios. 

		Example 1:
			
			Let's say hex sequence "7F" indicates Dakuten mark for the following character. This 
			can be entered into the table in the following manner: 

				60=か
				7F60=が
						
		Example 2:
			
			Let's say hex sequence "7F" indicates Dakuten mark for the preceding character.
			This can be entered into the table in the following manner: 

				60=か
				607F=が
			
		Example 3:
		
			Let's say hex sequence "7F" indicates Dakuten mark that applies for all 
			characters until "7F" occurs again to turn it off. This can be done with 
			two tables containing table switch bytes in the following manner: 
			
			Table 1:
				
				@NORMAL
				60=か
				!7F=[Dakuten,]-1
			
			Table 2:
				
				@Dakuten
				60=が
					
			This will instruct any dumper to output 'か' normally until a "7F" byte 
			is encountered. It will then switch to Table 2 and output 'が'. Because 
			we specified -1 for the number of table matches, matching in the new 
			table will continue until a "7F" is encountered to end. When "7F" is 
			encountered in Table 2, so fallback to Table 1 will occur. 
			
			See section 2.5.3 Table Switching for more information.


	3.3 Kanji or Han Ideographs

		This is an Asian-language specific issue. There are thousands of these 
		characters and they are often represented by multiple bytes in video games
			
		Typical multi-byte Kanji or Han characters can be handled via "Normal 
		Entries" in the following fashion: 
		
		Example 1:
			
			FD00=倒
			FD01=力
			FD02=罪

		Alternatively, table switching could be used. 
		
		Example 2:
		
			Table1:
				
				@NORMAL
				00=a
				01=b
				!FD=[KANJI],1
			
			Table 2:
			
				@KANJI
				00=倒
				01=力
				02=罪
		
		Table switching can also cover more complex situations. 
		
		Example 3:
		
			In many games, kanji are stored as dual-byte values, such as:

				C0 12

			To save space, some game developers used kanji array encoding for
			saving space with long lists of kanji in a row. A normal kanji array
			string might look like this:

				C0 12 34 56   
			
			which would be the equivalent to:

				C0 12 C0 34 C0 56

			A table entry to handle this situation would look like this:

				!C0=KanjiTableID,3
				
			"C0" is the array trigger/table switch byte, "3" is how many matches (in 
			this case bytes) following it are to be matched from the new table before 
			falling back to the first. 

			See section 2.5.3 Table Switching for more information.	
		
	3.4 Hiragana/Katakana Table switching

		This is a Japanese-language specific issue. In short, Hiragana/Katakana 
		represent the same spoken syllables in two forms. Some games may use a 
		table switch byte to indicate Hiragana or Katakana for the same hex 
		value. This can be handled by using a table switch hex code under the 
		"Table Switching" section (2.5.3). 
		
		Example 1:
			
			Let's say hex sequence "E0" indicates Hiragana/Katakana switching for the next byte.
			This can be entered into the table in the following manner: 

				30=あ
				E030=ア

			Alternatively, table switching may be used to handle some more complicated situations. 

		Example 2:
		
			Let's say hex sequence "E0" indicates Hiragana/Katakana that applies for all 
			characters until "E0" occurs again to turn it off. This can be done with 
			two tables containing table switch hex codes in the following manner: 
			
			Table 1:
				
				@HIRAGANA
				30=あ
				!E0=KATAKANA,0
			
			Table 2:
				
				@KATAKANA
				30=ア
					
			This will instruct any dumper to output 'あ' normally until a E0 byte 
			is encountered. It will then switch to Table 2 and output 'ア'. Because 
			we specified 0 for the number of table matches, matching in the new 
			table will continue until a value is not found. In this case "E0" is not 
			in the Table 2, so fallback to Table 1 will occur. 


	
4.0 Suggestions to Programmers handling Table Files


	4.1 Cross-Platform Newline support.
		
		Please be aware newline values may be different on different platforms. 
		Unix and Windows Platforms use LF (0x0A) and CR+LF, (0x0D 0x0A0) 
		respectively. Macintosh uses CR only (0x0D). It's best practice when 
		reading the table file, as well as dealing with escape codes (\n) to 
		handle all three types. Most programming languages provide string reading 
		functions already able to handle this issue. You should also ensure any 
		other libraries you may use will handle newlines appropriately. 

		Any .NET based language can use StreamReader.ReadLine(). C++ can use 
		iostream.getline(). Other languages should also have appropriate 
		facilities. Unless highly skilled, avoid binary processing on the table. 
		Use encoding-aware text/string processing functions. 
	
	4.2 Dumping vs. Inserting Considerations
		
		Please be aware some features of the table file format must be treated 
		differently depending upon whether the task is dumping or inserting. 
		
		Formatting sequences such as "\n" typically are needed for format 
		control over dumping only. They must be automatically stripped by the 
		insertion utility as they are no longer needed. End Tokens will be used 
		for string end purposes for insertion. 
		
		End Tokens are only needed to indicate end-of-string for pointer-related 
		functionality. They may not be needed for other dumping or inserting 
		cases. 

		Linked Entries are utilized differently for dumping and inserting 
		purposes. The parameter portion of linked entries is ignored for 
		insertion as the parameter hex bytes are already in the script in 
		"[$XX]" form. Inserting would flow through the stream inserting the 
		trigger hex sequence for the linked entry continuing on seeing the 
		"[$XX]" formatted hex bytes in the script. 

	4.3 Data Structures for Entry Handling

		Here are some suggestions on structurally handling the different types 
		of entries. There are of course many ways to do it. 

		1. Most normal entries can be contained in a typical <string/string> 
		Key/Value pair, map, hash table, or dictionary, however the target language 
		supports it. 

		2. End tokens can be contained in a simple array list/vector. Remember to 
		also add as a normal entry for dumping purposes. 
		
		3. Linked Entries will be parsed and require a custom 
		structure/type. Remember to also include the relevant portion as a 
		normal entry for inserting purposes. 

		4. It is recommended that Linked Entries be wrapped 
		into a typical map, hash table, or dictionary. The hex will be the key 
		and the value will be the structure.

	
	
5.0 Lexical Definitions
		
	
	Duplicate: 
		A repeat occurence of a value within a single logical table.

	Hex Digit: 
		Upper or Lower Case 
		0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
	
	Hex Byte:
		HexDigit HexDigit
	
	Hex Value: 
		HexByte+ where + denotes one or more instances of a value.
	
	Logical Table:
		Collection of hex sequence to text sequence conversion entries
		preceded by a TableID.
	
